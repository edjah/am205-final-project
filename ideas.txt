a, b, c = torch_requires_grad()

def evaluate(f):
    f_x = finite_difference(F, 'x')
    x = np.arange(10000)
    return sum((a*f + b*f_x + c*f_y + d*x + e*y + F) ** 2)

f = minimize(evaluate, random_guess())



f = b/a*f_x + c/a*f_y + d/a*x + e/a*y + F

loss = sum (f_true - f) ^ 2





f(x, y) = exp(2x) + exp(y)

f_x = 2exp(2x)

f_xx = 4exp(2x)

f_y = exp(y)
f_yy = exp(y)


f_xx/4 + f_yy = f(x, y)



dt = 0.01

x_0 = ...
v_0 = ...

v_1 = v_0 + F() / m * dt
x_1 = x_0 + v_1 * dt



F = Gm1 m2 / (pos0 - x1)^2
